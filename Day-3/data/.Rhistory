ge <- genes(txdb)
# promoter ranges for a specified width around TSS
prom <- promoters(txdb, upstream=1000, downstream=0)
# non-overlapping introns or exons
exonicParts(txdb)
intronicParts(txdb)
################################################
# return all transcript ranges organized by gene
txs_by_gene <- transcriptsBy(txdb, by = "gene")
txs_by_gene
# index by gene.id of interest to get all transcripts annotated to that gene -
# Error: subscript contains invalid names
txs_by_gene["ENSG00000000419"]
# index by exons by transcript (to identify unique exons)
ex_by_gene <- exonsBy(txdb, by = "tx")
ex_by_gene
txs_by_gene
# index by gene.id of interest to get all transcripts annotated to that gene -
# Error: subscript contains invalid names
txs_by_gene["ENSG00000000419"]
# index by exons by transcript (to identify unique exons)
ex_by_gene <- exonsBy(txdb, by = "tx")
ex_by_gene
################################################ - Left off here
# look at the columns avaialble to be returned in the Txdb
columns(txdb)
# return the transcripts annotated to a specific gene of interest
gene_to_tx <- select(txdb, keys = "ENSG00000273696", columns="TXNAME", keytype="GENEID")
gene_to_tx
# return the transcripts annotated to a specific gene of interest
gene_to_tx <- select(txdb, keys = "ENSG00000273696", columns="TXNAME", keytype="GENEID")
gene_to_tx
# return tx to gene mapping for top 500 RNA-seq diff. exp. results
gene_to_tx <- select(txdb, keys = head(rownames(results), 500) , columns="TXNAME", keytype="GENEID")
head(gene_to_tx)
dim(gene_to_tx)
# check for duplicate entries
table(duplicated(gene_to_tx$GENEID))
table(duplicated(gene_to_tx$TXNAME))
# return exons IDs, their coordinates, and strand for top 10 transcripts from RNA-seq results
tx_to_exon <- select(txdb, keys = head(gene_to_tx, 10)$TXNAME ,
columns=c("EXONCHROM", "EXONNAME", "EXONSTART",
"EXONEND", "EXONSTRAND", "GENEID"), keytype="TXNAME")
tx_to_exon
# again, check for duplicate entries
table(duplicated(tx_to_exon$TXNAME))
################################################ - Left off here
# look at the columns avaialble to be returned in the Txdb
columns(txdb)
# return the transcripts annotated to a specific gene of interest
gene_to_tx <- select(txdb, keys = "ENSG00000273696", columns="TXNAME", keytype="GENEID")
txdb
# index by gene.id of interest to get all transcripts annotated to that gene -
# Error: subscript contains invalid names
txs_by_gene["ENSG00000000419"]
# index by exons by transcript (to identify unique exons)
ex_by_gene <- exonsBy(txdb, by = "tx")
ex_by_gene
################################################ - Left off here
# look at the columns avaialble to be returned in the Txdb
columns(txdb)
# return the transcripts annotated to a specific gene of interest
gene_to_tx <- select(txdb, keys = "ENSG00000273696", columns="TXNAME", keytype="GENEID")
txdb
txs_by_gene
names(txdb)
txs_by_gene
# assign to txdb variable
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
txdb
################################################
# retrieve all transcript level info
txs <- transcripts(txdb)
txs
# what class is it?
class(txs)
# how long is it
length(txs)
# what is the distribution of transcripts across strands
table(strand(txs))
################################################
# retireve all the exon ranges
ex <- exons(txdb)
# retireve all the gene ranges
ge <- genes(txdb)
ge
# promoter ranges for a specified width around TSS
prom <- promoters(txdb, upstream=1000, downstream=0)
# non-overlapping introns or exons
exonicParts(txdb)
intronicParts(txdb)
#### DO RUN ####
txdb <- loadDb("~/Desktop/TxDb.Hsapiens.Ensembl.101.db")
################################################
# retrieve all transcript level info
txs <- transcripts(txdb)
txs
# what class is it?
class(txs)
# how long is it
length(txs)
# what is the distribution of transcripts across strands
table(strand(txs))
################################################
# retireve all the exon ranges
ex <- exons(txdb)
# retireve all the gene ranges
ge <- genes(txdb)
# promoter ranges for a specified width around TSS
prom <- promoters(txdb, upstream=1000, downstream=0)
# non-overlapping introns or exons
exonicParts(txdb)
intronicParts(txdb)
################################################
# return all transcript ranges organized by gene
txs_by_gene <- transcriptsBy(txdb, by = "gene")
txs_by_gene
# index by gene.id of interest to get all transcripts annotated to that gene -
# Error: subscript contains invalid names
txs_by_gene["ENSG00000000419"]
# index by exons by transcript (to identify unique exons)
ex_by_gene <- exonsBy(txdb, by = "tx")
ex_by_gene
################################################ - Left off here
# look at the columns avaialble to be returned in the Txdb
columns(txdb)
# return the transcripts annotated to a specific gene of interest
gene_to_tx <- select(txdb, keys = "ENSG00000273696", columns="TXNAME", keytype="GENEID")
gene_to_tx
# return tx to gene mapping for top 500 RNA-seq diff. exp. results
gene_to_tx <- select(txdb, keys = head(rownames(results), 500) , columns="TXNAME", keytype="GENEID")
head(gene_to_tx)
dim(gene_to_tx)
# check for duplicate entries
table(duplicated(gene_to_tx$GENEID))
table(duplicated(gene_to_tx$TXNAME))
# return exons IDs, their coordinates, and strand for top 10 transcripts from RNA-seq results
tx_to_exon <- select(txdb, keys = head(gene_to_tx, 10)$TXNAME ,
columns=c("EXONCHROM", "EXONNAME", "EXONSTART",
"EXONEND", "EXONSTRAND", "GENEID"), keytype="TXNAME")
tx_to_exon
# again, check for duplicate entries
table(duplicated(tx_to_exon$TXNAME))
################################################
library(VariantAnnotation)
# import the variant locations in bed file format
bed <- import("TCGA.pcawg.chr17.bed", format="BED")
bed
# annotate the variants based on our Ensembl Txdb
vars <- locateVariants(bed, txdb, AllVariants())
vars
################################################
# sum up variants in each group
sum.tab <- table(vars$LOCATION)
sum.tab
# calculate a quick proprtions table
round(prop.table(sum.tab), digits = 2)
# quick visualization
barplot(round(prop.table(table(vars$LOCATION)), digits = 2))
################################################
#
anno <- read.table("GRCh38.p12_ensembl-101.txt", sep="\t", header=TRUE, stringsAsFactors = F)
# return indicies of ENSEMBL geneIDs from variants annotation in the Ensembl v101 annotation data
indicies_of_matches <- match(vars$GENEID, anno$Gene.stable.ID)
# add gene symbols to vars object
vars$GENE.SYMBOL <- anno$Gene.name[indicies_of_matches]
# exmaple gene of interest:
vars_cd79b <- vars[vars$GENE.SYMBOL %in% "CD79B",]
vars_cd79b
# check how many of each variant type
table(vars_cd79b$LOCATION)
################################################
# required to set expectation for format of chromosome names ('chr17' vs '17')
options(ucscChromosomeNames=FALSE)
library(Gviz)
# set gene region track from our txdb
txTr <- GeneRegionTrack(txdb,
chromosome = "17",
start = (min(start(vars_cd79b)) - 500),
end =  (max(start(vars_cd79b) + 500)),
name = "Ensembl v101")
# create the annotation track for the variants of interest
track1 <- AnnotationTrack(granges(vars_cd79b), name = "TCGA variants",
col.line = "red", fill = "red")
# add the genome axis for scale
gtrack <- GenomeAxisTrack()
# generate the plot
plotTracks(list(gtrack, txTr, track1), main="CD97B variants")
################################################
# we will use a pre-loaded txdb for mm10 in this example
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
# set txdb to variable
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
# set extracols for reading in narrowpeak data
extraCols_narrowPeak <- c(signalValue = "numeric", pValue = "numeric",
qValue = "numeric", peak = "integer")
BiocManager::install("TxDb.Mmusculus.UCSC.mm10.knownGene")
################################################
# we will use a pre-loaded txdb for mm10 in this example
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
# set txdb to variable
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene
# set extracols for reading in narrowpeak data
extraCols_narrowPeak <- c(signalValue = "numeric", pValue = "numeric",
qValue = "numeric", peak = "integer")
# forbrain H3K27ac ChIP-seq peaks
fr_h3k27ac <- rtracklayer::import("forebrain_E15.5_H3K27ac.bed",
format = "BED",
extraCols = extraCols_narrowPeak,
genome = "mm10")
# heart H3K27ac ChIP-seq peaks
ht_h3k27ac <- rtracklayer::import("heart_E15.5_H3K27ac.bed",
format = "BED",
extraCols = extraCols_narrowPeak,
genome = "mm10")
# forbrain H3K9ac ChIP-seq peaks
fr_h3k9ac <- rtracklayer::import("forebrain_E15.5_H3K9ac.bed",
format = "BED",
extraCols = extraCols_narrowPeak,
genome = "mm10")
# heart H3K9ac ChIP-seq peaks
ht_h3k9ac <- rtracklayer::import("heart_E15.5_H3K9ac.bed",
format = "BED",
extraCols = extraCols_narrowPeak,
genome = "mm10")
# combine with H3K27ac peak sets to make GrangesList objects
fr <- GRangesList("h3K27ac" = fr_h3k27ac, "h3K9ac" = fr_h3k9ac)
ht <- GRangesList("h3K27ac" = ht_h3k27ac, "h3K9ac" = ht_h3k9ac)
################################################
library(ChIPseeker)
# run annotatePeak
fr_h3K27ac_anno <- annotatePeak(fr$h3K27ac, tssRegion=c(-2000, 1000), TxDb = txdb)
BiocManager::install("ChIPseeker")
################################################
library(ChIPseeker)
# run annotatePeak
fr_h3K27ac_anno <- annotatePeak(fr$h3K27ac, tssRegion=c(-2000, 1000), TxDb = txdb)
class(fr_h3K27ac_anno)
?annotatePeak
# extract and print the annotation data
fr_h3K27ac_anno <- fr_h3K27ac_anno@anno
fr_h3K27ac_anno
# what class is it
class(fr_h3K27ac_anno)
################################################
annolist <- lapply(list(fr$h3K27ac, ht$h3K27ac, fr$h3K9ac, ht$h3K9ac),
annotatePeak,
TxDb=txdb,
tssRegion=c(-2000, 1000), verbose=FALSE)
# set the names for each element of the list
names(annolist) <- c('Forebrain_H3K27ac', 'Heart_H3K27ac',
'Forebrain_H3K9ac', 'Heart_H3K9ac')
annolist
annolist[[1]]
annolist$Forebrain_H3K27ac
################################################
plotAnnoBar(annolist)
################################################
#extract annotation data for heart h3k9ac
ht_h3K9ac_anno <- annolist$Heart_H3K9ac@anno
# subset for promoter-associated peaks
ht_h3K9ac_anno_promoter <- ht_h3K9ac_anno[ht_h3K9ac_anno$annotation=="Promoter (<=1kb)" |
ht_h3K9ac_anno$annotation=="Promoter (1-2kb)"]
ht_h3K9ac_anno_promoter
################################################
# convert GRanges to dataframe
df1 <- as.data.frame(fr_h3K27ac_anno)
# write to csv
write.csv(df1, file = "forebrain_h3K27ac_peaks_annotated_mm10.csv")
setwd("/Users/omw/Documents/GitHub/Bioinformatics_workshop-Dec-2021/Day-3/data/")
########################################
library(BSgenome)
available.genomes()
########################################
# use the DNAString contructor function to create a 10 letter DNA sequence
seq <- DNAString(x="AGCT", start=1, nchar=NA)
seq
# how long is it
length(seq)
# show the structure of the DNAString object
str(seq)
########################################
# print DNA alphabet to see what it returns
DNA_ALPHABET
########################################
IUPAC_CODE_MAP
########################################
# randomly sample from specific characters in DNA_ALPHABET to create a longer sequence
seq = sample(DNA_ALPHABET[c(1:4, 16)], size=100, replace=TRUE)
seq
# use the paste command to collapse the characters into a single string
seq = paste(seq, collapse="")
seq
# use the DNAString constructor function to turn this sequence into a DNAString class object
seq.dnastring <- DNAString(seq)
seq.dnastring
########################################
# confirm how long it is
length(seq.dnastring)
# what is the frequency of each base in your sequence
alphabetFrequency(seq.dnastring, baseOnly=TRUE, as.prob=TRUE)
# what is the frequency of your favourite base (which is obviously Adenine)
letterFrequency(seq.dnastring, "A", as.prob=TRUE)
# return the frequency of dinucleotide pairs
dinucleotideFrequency(seq.dnastring, as.prob=TRUE)
# or even trinucleotides
trinucleotideFrequency(seq.dnastring, as.prob=TRUE)
########################################
# subset the sequence for 10 specific bases of interest
seq.dnastring[10:19]
# this can also be done with the `subseq()` function
subseq(seq.dnastring, 10, 19)
# get the reverse of our sequence
reverse(seq.dnastring)
# get the reverse COMPLEMENT sequence
reverseComplement(seq.dnastring)
# get the reverse complement of the first 10 bases in your sequence
reverseComplement(subseq(seq.dnastring, 1, 10))
# translate our DNA sequence
translate(seq.dnastring)
########################################
# remove the old single sequence from our global R environment
rm(seq)
# create a new variable, and fill it with individual sequences created as we did above
seq.dnass <- NULL
seq.dnastring
########################################
# remove the old single sequence from our global R environment
rm(seq)
# create a new variable, and fill it with individual sequences created as we did above
seq.dnass <- NULL
seq.dnass[1] = paste(sample(DNA_ALPHABET[c(1:4)], size=50, replace=TRUE), collapse="")
seq.dnass[2] = paste(sample(DNA_ALPHABET[c(1:4)], size=50, replace=TRUE), collapse="")
seq.dnass[3] = paste(sample(DNA_ALPHABET[c(1:4)], size=50, replace=TRUE), collapse="")
seq.dnass[4] = paste(sample(DNA_ALPHABET[c(1:4)], size=50, replace=TRUE), collapse="")
seq.dnass[5] = paste(sample(DNA_ALPHABET[c(1:4)], size=50, replace=TRUE), collapse="")
seq.dnass
# how long is this object
length(seq.dnass)
# use the constructor function DNAStringSet to make the DNAStringSet object with your sequences
dna.st.set = DNAStringSet(seq.dnass)
# how long is the DNAStringSet object
length(seq.dnass)
# name all your sequences
names(seq.dnass) = paste("barcode-", 1:5, sep="")
seq.dnass
########################################
# assign the genome to a variable using getBSgenome()
genome <- getBSgenome("BSgenome.Mmusculus.UCSC.mm10")
genome
# check the structure
str(genome)
# print the metadata for the genome
metadata(genome)
########################################
genome.m <- getBSgenome("BSgenome.Mmusculus.UCSC.mm10.masked")
class(genome.m)
########################################
# assign the genome to a variable using getBSgenome()
genome <- getBSgenome("BSgenome.Mmusculus.UCSC.mm10")
genome
# check the structure
str(genome)
# print the metadata for the genome
metadata(genome)
########################################
genome.m <- getBSgenome("BSgenome.Mmusculus.UCSC.mm10.masked")
class(genome.m)
BiocManager::install("BSgenome.Mmusculus.UCSC.mm10.masked")
class(genome.m)
########################################
genome.m <- getBSgenome("BSgenome.Mmusculus.UCSC.mm10.masked")
class(genome.m)
genome.m
# unmasked genome
class(genome)
genome
########################################
# return basic sequence information summary
seqinfo(genome.m)
# print chromosome 1
genome.m$chr1
# unmasked genome
seqinfo(genome)
genome$chr1
########################################
rm(genome)
genome <- getBSgenome("BSgenome.Mmusculus.UCSC.mm10.masked")
########################################
# assign chr 1
chr1 <- genome$chr1
# confirm how long it is
length(chr1)
# what is the frequency of each base in your sequence
alphabetFrequency(chr1, baseOnly=TRUE, as.prob=TRUE)
# what is the frequency of your favourite base
letterFrequency(chr1, "A", as.prob=TRUE)
########################################
# we need to establish a vector describing what the extra extended BED columns are
extraCols_narrowPeak <- c(signalValue = "numeric", pValue = "numeric",
qValue = "numeric", peak = "integer")
# read in peaks
bed <- import("CTCF-forebrain-mm10.bed", extraCols = extraCols_narrowPeak, format="BED")
bed
# extract sequences for peak regions and print to console -first command take a minute or two
ctcf_seqs <- getSeq(genome, bed)
ctcf_seqs
########################################
# calculate nucleotide freqs.
nt_freqs <- alphabetFrequency(ctcf_seqs, baseOnly=TRUE, as.prob=TRUE)
# calculate mean value for nucleotide freqs across all peaks
round(apply(nt_freqs, 2, mean), digits=2)
########################################
hist(width(ctcf_seqs),
col = "darkgray",
xlab = "Peak width (bp)",
main = "CTCF peak width distribution")
########################################
# resize the regions from the BED file
bed_centered <- resize(bed, width = 400, fix = "center")
bed_centered
# check their with
width(bed_centered)
# extract sequences again
ctcf_seqs_cent <- getSeq(genome, bed_centered)
ctcf_seqs_cent
########################################
# export peaks to FASTA file
writeXStringSet(ctcf_seqs, file="CTCF-peaks-resized.fa")
######################################## Started here again
fasta.file <- "a.queenslandica.fasta"
a.queen <- readDNAStringSet(fasta.file, "fasta")
a.queen
########################################
# confirm how long it is
length(a.queen)
# what is the frequency of each base in your sequence
base.freqs <- alphabetFrequency(a.queen, baseOnly=TRUE, as.prob=TRUE)
base.freqs
# what is the frequency of your favourite base
a.freqs <- letterFrequency(a.queen, "A", as.prob=TRUE)
a.freqs
########################################
# return all matches in a DNAString subject sequence to a query pattern
matchPattern("ATG", a.queen[[1]])
# only return how many counts were found
countPattern("ATG", a.queen[[1]])
# what happens if we remove the indexing of the DNAStringSet object 'a.queen'? Why?
matchPattern("ATG", a.queen)
# match a query sequence against multiple sequences that you want to search in
vmatch <- vmatchPattern("ATG", a.queen)
vmatch
# look at the structure of this object
str(vmatch)
# extract the IRanges for matches in the first subject sequence
vmatch[[1]]
########################################
# create a DNAStringSet of the stop codons
stop.codons <- DNAStringSet(c("TAG", "TAA", "TGA"))
# create a dictionary of patterns (PDict class object) that you want to search your sequences for
stop.codons.dict <- PDict(stop.codons)
# search in the first coding sequence
match1 <- matchPDict(stop.codons.dict, a.queen[[1]])
match1
match1[[3]]
# use a loop to search for stop codons in all our coding sequences
matches <- list()
for(i in 1:length(a.queen)){
matches[[i]] <- matchPDict(stop.codons.dict, a.queen[[i]])
}
length(matches)
str(matches)
matches[[4]]
matches[[4]][[3]]
# read in the example data
dat3 <- read.csv("lm-example-3.csv", stringsAsFactors=FALSE, row.names = 1)
# quickly explore it
head(dat3)
table(dat3$subject_group)
# visualize the data
boxplot(dat3$exp_geneX ~ dat3$subject_group ,
ylab = "Expression (Gene X)",
xlab = "Subject group",
main = "Gene X exp. vs Hba1c",
col = c("indianred", "cornflowerblue"), pch = 16, las = 1)
# run the linear model and evaluate
lm_2 <- lm(dat3$exp_geneX ~ dat3$subject_group)
summary(lm_2)
summary(lm(dat3$exp_geneX ~ dat3$subject_group + dat3$age + dat3$gender + dat3$batch))
dat3
# read in the example data
dat3 <- read.csv("lm-example-3.csv", stringsAsFactors=FALSE, row.names = 1)
dat3
# read in the example data
dat3 <- read.csv("lm-example-3.csv", stringsAsFactors=FALSE, row.names = 1)
dat3
summary(lm(dat3$exp_geneX ~ dat3$subject_group + dat3$age + dat3$gender + dat3$batch))
# read in the example data
dat3 <- read.csv("lm-example-3.csv", stringsAsFactors=FALSE, row.names = 1)
# quickly explore it
head(dat3)
table(dat3$subject_group)
# visualize the data
boxplot(dat3$exp_geneX ~ dat3$subject_group ,
ylab = "Expression (Gene X)",
xlab = "Subject group",
main = "Gene X exp. vs Hba1c",
col = c("indianred", "cornflowerblue"), pch = 16, las = 1)
# run the linear model and evaluate
lm_2 <- lm(dat3$exp_geneX ~ dat3$subject_group)
summary(lm_2)
summary(lm(dat3$exp_geneX ~ dat3$subject_group + dat3$age + dat3$gender + dat3$batch))
